---
part: "第II部: 実装パターン編"
page_count: 40
title: "借用とライフタイム - 安全な参照管理"
---

# 第4章: 借用とライフタイム - 安全な参照管理

## 学習目標
この章を読み終えると、以下ができるようになります：
- [ ] なぜライフタイムが必要なのかを、ダングリングポインタの問題と関連付けて説明できる。
- [ ] ライフタイム省略規則を理解し、なぜ多くの関数でライフタイム指定が不要なのかを説明できる。
- [ ] ジェネリックライフタイムを使い、コンパイラが推論できない参照の関係性を明示できる。
- [ ] 構造体に参照を保持させ、そのライフタイムを正しく管理できる。

---

## 4.1 導入：なぜライフタイムという概念が必要なのか？

第2章で、Rustがダングリングポインタをコンパイル時に防ぐと学びました。では、**どのように**してそれを実現しているのでしょうか？以下のコードを考えてみましょう。

```rust,ignore
let r; // 参照 `r` を宣言

{ // 内部スコープ開始
    let x = 5; // 整数 `x` を宣言。これは内部スコープ内で有効
    r = &x; // `r` は `x` への参照を持つ
} // 内部スコープ終了。ここで `x` はスコープを抜け、メモリが解放される

println!("r: {}", r); // `r` は解放されたメモリを指す！危険！
```

このコードがもしコンパイルを通ってしまえば、`r`は無効なメモリを指す「ダングリングリファレンス」となり、未定義動作を引き起こします。Rustのコンパイラ（特に**借用検査器 (Borrow Checker)**）の仕事は、このような状況を決して許さないことです。

**CSのポイント:** ダングリングポインタやUse-After-Free（解放済みメモリ使用）は、CSの**「メモリ安全性」**における最も古典的で深刻な問題です。これらは、プログラムのクラッシュ、データの破損、さらには悪意のあるコード実行（セキュリティ脆弱性）に繋がる可能性があります。Rustのライフタイムシステムは、CSの**「静的解析」**を用いて、これらの問題をコンパイル時に完全に排除することを目指します。

借用検査器は、全ての参照が、それが指し示す先のデータよりも長く生存しないことを保証します。この「生存期間」を管理するための概念が**ライフタイム**です。難しく考える必要はありません。**ライフタイムとは、コンパイラがスコープを識別するために付ける「名前」**のようなものです。

`[図：ダングリングポインタの発生メカニズム。メモリ上で変数`x`が確保され、`r`がそれを参照する。`x`のスコープが終了しメモリが解放された後も`r`が残存し、無効なメモリを指し示す様子を時系列で示す。]`

---

## 4.2 コンパイラの魔法：ライフタイム省略規則

驚くべきことに、これまでの章で私たちはライフタイムを一度も明示的に書いてきませんでした。それは、ほとんどの一般的なケースでは、コンパイラが**ライフタイム省略規則（Lifetime Elision Rules）**という3つのシンプルなルールを適用して、自動的にライフタイムを推論してくれるからです。このルールを理解することが、ライフタイムをマスターする第一歩です。

**CSのポイント:** ライフタイム省略規則は、CSの**「型推論」**や**「コンパイラ最適化」**の応用例です。コンパイラが一般的なパターンを認識し、自動的にライフタイムを補完することで、開発者は冗長な記述を避けつつ、強力な静的保証の恩恵を受けることができます。これは、CSの**「プログラマの負担軽減」**と**「言語の表現力向上」**を両立させる設計思想の現れです。

### 4.2.1 第一規則：入力参照はそれぞれ異なるライフタイムを持つ

コンパイラは、関数の入力パラメータ（引数）にある参照は、それぞれが独立したライフタイムを持つと仮定します。

- **書いたコード:** `fn foo(x: &i32, y: &str)`
- **コンパイラの解釈:** `fn foo<'a, 'b>(x: &'a i32, y: &'b str)`

`'a`と`'b`という異なる名前が、それぞれの参照のスコープに付けられます。これは、`x`と`y`が互いに独立した生存期間を持つ可能性があることを示します。

### 4.2.2 第二規則：入力ライフタイムが一つなら、出力にも同じものが使われる

入力参照が一つしかない場合、その参照のライフタイムが出力の参照にも適用されると仮定します。なぜなら、出力の参照は入力の参照から派生したもの以外ありえないからです。

- **書いたコード:** `fn first_word(s: &str) -> &str`
- **コンパイラの解釈:** `fn first_word<'a>(s: &'a str) -> &'a str`

これにより、返される`&str`が、入力`s`よりも長く生存することはない、とコンパイラは保証できます。もし`s`が先に無効になれば、返り値も自動的に無効になります。

### 4.2.3 第三規則：入力に`&self`か`&mut self`があれば、そのライフタイムが出力に使われる

メソッド（構造体やenumに実装された関数）の場合、`&self`や`&mut self`のライフタイムが非常に重要であるため、コンパイラはこれを優先します。

- **書いたコード:** `impl<'a> ImportantExcerpt<'a> { fn announce_and_return_part(&self, announcement: &str) -> &str { ... } }`
- **コンパイラの解釈:** `impl<'a> ImportantExcerpt<'a> { fn announce_and_return_part<'b>(&'a self, announcement: &'b str) -> &'a str { ... } }`

`self`のライフタイム`'a`が、返り値のライフタイムとして自動的に選択されます。これにより、メソッドが`self`の内部データを返すような一般的なケースで、ライフタイム指定を省略できます。

`[図：ライフタイム省略規則のフローチャート。関数のシグネチャが与えられたときに、どの規則が適用され、どのようにライフタイムが推論されるかを示す。]`

---

## 4.3 コンパイラを助ける：ジェネリックライフタイム

省略規則は多くのケースをカバーしますが、コンパイラが判断に迷う状況もあります。その場合は、私たちが明示的にライフタイムを注釈し、コンパイラを助けてあげる必要があります。

最も古典的な例が、二つの文字列スライスから長い方を返す`longest`関数です。

```rust,compile_fail
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

このコードはコンパイルエラーになります。なぜでしょうか？

コンパイラは省略規則を適用しようとします。第一規則により、`x`と`y`はそれぞれ`'a`と`'b`という異なるライフタイムを持つと解釈されます。しかし、返り値のライフタイムをどうすればよいでしょう？`x`を返すかもしれないし、`y`を返すかもしれない。コンパイラには、`'a`と`'b`のどちらを出力に適用すべきか判断できません。第二規則（入力が一つ）も第三規則（`&self`がある）も適用できません。

ここで、私たちが**ジェネリックライフタイムパラメータ**を使って、参照間の関係をコンパイラに教えます。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

この構文が意味することは以下の通りです。

1.  `<'a>`: ジェネリックライフタイム`'a`を宣言します。
2.  `x: &'a str, y: &'a str`: 引数`x`と`y`は、両方とも同じライフタイム`'a`を持つ参照であることを示します。
3.  `-> &'a str`: 返り値の参照も、同じライフタイム`'a`を持つことを示します。

これにより、「返される参照は、`x`と`y`のうち**短い方のスコープ**と同じ期間だけ有効である」という関係性をコンパイラに伝えることができます。これで、借用検査器は安心してこの関数が安全であることを検証できます。

**CSのポイント:** この「最も短いライフタイムに制約される」というルールは、CSの**「交差型（Intersection Type）」**や**「サブタイプ多相性」**の概念と関連付けることができます。複数の参照の生存期間の「共通部分」が、結果の参照の有効期間を決定するという考え方です。

`[図：ジェネリックライフタイムの制約。`x`と`y`という異なる長さのライフタイムを持つ参照が入力され、`longest`関数が返す参照のライフタイムが、`x`と`y`の共通部分（短い方）に制約される様子をタイムラインで示す。]`

---

## 4.4 構造体とライフタイム

ライフタイムが本当に重要になるのは、構造体が自分以外のデータへの参照を保持する場合です。

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let i = ImportantExcerpt {
        part: first_sentence,
    };
    // `i` は `novel` が有効な間だけ有効
}
```

`ImportantExcerpt`の定義でライフタイム`'a`を宣言することで、「この構造体のインスタンスは、`part`フィールドが指し示す参照`'a`よりも長く生存することはできない」という制約を課しています。これにより、`novel`がスコープを抜けて解放された後に`i`が残ってしまう、というダングリングポインタの状態を防ぐことができます。

**CSのポイント:** 構造体が参照を保持する際のライフタイム指定は、CSの**「データ構造の健全性」**を保証するために不可欠です。特に、自己参照構造体（構造体自身が自分の一部への参照を持つ）のような複雑なケースでは、ライフタイムがポインタの安定性を静的に検証する役割を果たします。Rustの`Pin`のような高度な概念は、このような自己参照構造体を安全に扱うためのCS的な解決策です。

`[図：構造体が参照を保持する際のライフタイム。`novel`というデータと、それへの参照を持つ`ImportantExcerpt`インスタンス`i`のライフタイムの関係をタイムラインで示す。`novel`が先に無効になると`i`も無効になることを強調。]`

---

## 4.5 特別なライフタイム：`'static`

`'static`は、プログラムの全実行期間にわたって生存する参照を表す、特別なライフタイムです。最も身近な例は、プログラムのバイナリに直接埋め込まれる文字列リテラルです。

```rust
let s: &'static str = "I have a static lifetime.";
```

この文字列はプログラムの開始から終了まで常に有効なメモリ領域にあるため、`'static`ライフタイムを持つことが保証されます。

**CSのポイント:** `'static`ライフタイムは、CSの**「プログラムのメモリレイアウト」**におけるデータセグメントやコードセグメントに配置されるデータと関連付けられます。これらのデータは、プログラムの実行開始から終了まで常にメモリ上に存在するため、その参照は`'static`であると見なされます。

`'static`は、以下のような様々なユースケースで活用されます。

*   **グローバル定数:** プログラム全体で共有される不変のデータ。
    ```rust
    static GLOBAL_MESSAGE: &str = "This message lives forever.";
    ```
*   **シングルトンパターン:** アプリケーション全体で唯一のインスタンスを保証するパターン。`lazy_static`や`once_cell`クレートと組み合わせて使われることが多いです。
*   **スレッド間で共有される不変データ:** `Send`や`Sync`トレイトと組み合わせて、スレッド間で安全に共有される不変のデータ（例：設定情報）を表現する際に使われます。
    ```rust
    fn process_data(data: &'static [u8]) { /* ... */ }
    ```
    この場合、`data`はプログラムの全期間にわたって有効なメモリ領域にあることが保証されるため、スレッド間で安全に参照を渡すことができます。

---

## 4.6 まとめ

本章では、ライフタイムという、Rustで最も革新的かつ難解とされる概念の一つを学びました。

- [ ] **ライフタイムはスコープに関するもの:** 借用検査器が参照の有効範囲を検証するための仕組みです。
- [ ] **コンパイラは賢い:** ほとんどの場合、ライフタイム省略規則によって、私たちがライフタイムを記述する必要はありません。
- [ ] **コンパイラを助ける:** 省略規則で解決できない曖昧なケースでのみ、`<'a>`構文を使って参照間の関係を明示します。
- [ ] **コストはゼロ:** これら全てのチェックは、コンパイル時に行われ、実行時のパフォーマンスへの影響は一切ありません。

借用とライフタイムのシステムは、C/C++が長年抱えてきたメモリエラーの問題を、GCのオーバーヘッドなしに解決するための、Rustのエレガントな解答なのです。

次章では、これらの安全性保証を土台として、Rustがどのようにして恐れることなく並行処理を記述できるのか、その理論と実践に踏み込んでいきます。