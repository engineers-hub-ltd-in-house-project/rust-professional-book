# 第4章: 借用とライフタイム - 安全な参照管理

## 学習目標
本章を修了すると、以下が可能になります：
- [ ] なぜライフタイムが必要なのかを、ダングリングポインタの問題と関連付けて説明できる。
- [ ] ライフタイム省略規則を理解し、なぜ多くの関数でライフタイム指定が不要なのかを説明できる。
- [ ] ジェネリックライフタイムを使い、コンパイラが推論できない参照の関係性を明示できる。
- [ ] 構造体に参照を保持させ、そのライフタイムを正しく管理できる。

---

## 4.1 導入：なぜライフタイムという概念が必要なのか？

第2章で、Rustがダングリングポインタをコンパイル時に防ぐと学びました。では、**どのように**してそれを実現しているのでしょうか？以下のコードを考えてみましょう。

```rust,ignore
let r;

{
    let x = 5;
    r = &x; // rはxへの参照を持つ
} // ここでxはスコープを抜け、メモリが解放される

println!("r: {}", r); // rは解放されたメモリを指す！危険！
```

このコードがもしコンパイルを通ってしまえば、`r`は無効なメモリを指す「ダングリングリファレンス」となり、未定義動作を引き起こします。Rustのコンパイラ（特に**借用検査器 (Borrow Checker)**）の仕事は、このような状況を決して許さないことです。

借用検査器は、全ての参照が、それが指し示す先のデータよりも長く生存しないことを保証します。この「生存期間」を管理するための概念が**ライフタイム**です。難しく考える必要はありません。**ライフタイムとは、コンパイラがスコープを識別するために付ける「名前」**のようなものです。

---

## 4.2 コンパイラの魔法：ライフタイム省略規則

驚くべきことに、これまでの章で私たちはライフタイムを一度も明示的に書いてきませんでした。それは、ほとんどの一般的なケースでは、コンパイラが**ライフタイム省略規則（Lifetime Elision Rules）**という3つのシンプルなルールを適用して、自動的にライフタイムを推論してくれるからです。このルールを理解することが、ライフタイムをマスターする第一歩です。

### 4.2.1 第一規則：入力参照はそれぞれ異なるライフタイムを持つ

コンパイラは、関数の入力パラメータ（引数）にある参照は、それぞれが独立したライフタイムを持つと仮定します。

- **書いたコード:** `fn foo(x: &i32, y: &str)`
- **コンパイラの解釈:** `fn foo<'a, 'b>(x: &'a i32, y: &'b str)`

`'a`と`'b`という異なる名前が、それぞれの参照のスコープに付けられます。

### 4.2.2 第二規則：入力ライフタイムが一つなら、出力にも同じものが使われる

入力参照が一つしかない場合、その参照のライフタイムが出力の参照にも適用されると仮定します。なぜなら、出力の参照は入力の参照から派生したもの以外ありえないからです。

- **書いたコード:** `fn first_word(s: &str) -> &str`
- **コンパイラの解釈:** `fn first_word<'a>(s: &'a str) -> &'a str`

これにより、返される`&str`が、入力`s`よりも長く生存することはない、とコンパイラは保証できます。

### 4.2.3 第三規則：入力に`&self`か`&mut self`があれば、そのライフタイムが出力に使われる

メソッド（構造体やenumに実装された関数）の場合、`&self`や`&mut self`のライフタイムが非常に重要であるため、コンパイラはこれを優先します。

- **書いたコード:** `impl<'a> ImportantExcerpt<'a> { fn announce_and_return_part(&self, announcement: &str) -> &str { ... } }`
- **コンパイラの解釈:** `impl<'a> ImportantExcerpt<'a> { fn announce_and_return_part<'b>(&'a self, announcement: &'b str) -> &'a str { ... } }`

`self`のライフタイム`'a`が、返り値のライフタイムとして自動的に選択されます。これにより、メソッドが`self`の内部データを返すような一般的なケースで、ライフタイム指定を省略できます。

---

## 4.3 コンパイラを助ける：ジェネリックライフタイム

省略規則は多くのケースをカバーしますが、コンパイラが判断に迷う状況もあります。その場合は、私たちが明示的にライフタイムを注釈し、コンパイラを助けてあげる必要があります。

最も古典的な例が、二つの文字列スライスから長い方を返す`longest`関数です。

```rust,compile_fail
fn longest(x: &str, y: &str) -> &str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

このコードはコンパイルエラーになります。なぜでしょうか？

コンパイラは省略規則を適用しようとします。第一規則により、`x`と`y`はそれぞれ`'a`と`'b`という異なるライフタイムを持つと解釈されます。しかし、返り値のライフタイムをどうすればよいでしょう？`x`を返すかもしれないし、`y`を返すかもしれない。コンパイラには、`'a`と`'b`のどちらを出力に適用すべきか判断できません。第二規則（入力が一つ）も第三規則（`&self`がある）も適用できません。

ここで、私たちが**ジェネリックライフタイムパラメータ**を使って、参照間の関係をコンパイラに教えます。

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}
```

この構文が意味することは以下の通りです。

1.  `<'a>`: ジェネリックライフタイム`'a`を宣言します。
2.  `x: &'a str, y: &'a str`: 引数`x`と`y`は、両方とも同じライフタイム`'a`を持つ参照であることを示します。
3.  `-> &'a str`: 返り値の参照も、同じライフタイム`'a`を持つことを示します。

これにより、「返される参照は、`x`と`y`のうち**短い方のスコープ**と同じ期間だけ有効である」という関係性をコンパイラに伝えることができます。これで、借用検査器は安心してこの関数が安全であることを検証できます。

---

## 4.4 構造体とライフタイム

ライフタイムが本当に重要になるのは、構造体が自分以外のデータへの参照を保持する場合です。

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Ishmael. Some years ago...");
    let first_sentence = novel.split('.').next().expect("Could not find a '.'");
    
    let i = ImportantExcerpt {
        part: first_sentence,
    };
}
```

`ImportantExcerpt`の定義でライフタイム`'a`を宣言することで、「この構造体のインスタンスは、`part`フィールドが指し示す参照`'a`よりも長く生存することはできない」という制約を課しています。これにより、`novel`がスコープを抜けて解放された後に`i`が残ってしまう、というダングリングポインタの状態を防ぐことができます。

---

## 4.5 特別なライフタイム：`'static`

`'static`は、プログラムの全実行期間にわたって生存する参照を表す、特別なライフタイムです。最も身近な例は、プログラムのバイナリに直接埋め込まれる文字列リテラルです。

```rust
let s: &'static str = "I have a static lifetime.";
```

この文字列はプログラムの開始から終了まで常に有効なメモリ領域にあるため、`'static`ライフタイムを持つことが保証されます。

---

## 4.6 まとめ

本章では、ライフタイムという、Rustで最も革新的かつ難解とされる概念の一つを学びました。しかし、その核心はシンプルです。

- **ライフタイムはスコープに関するもの:** 借用検査器が参照の有効範囲を検証するための仕組みです。
- **コンパイラは賢い:** ほとんどの場合、ライフタイム省略規則によって、私たちがライフタイムを記述する必要はありません。
- **コンパイラを助ける:** 省略規則で解決できない曖昧なケースでのみ、`<'a>`構文を使って参照間の関係を明示します。
- **コストはゼロ:** これら全てのチェックは、コンパイル時に行われ、実行時のパフォーマンスへの影響は一切ありません。

借用とライフタイムのシステムは、C/C++が長年抱えてきたメモリエラーの問題を、GCのオーバーヘッドなしに解決するための、Rustのエレガントな解答なのです。

次章では、これらの安全性保証を土台として、Rustがどのようにして恐れることなく並行処理を記述できるのか、その理論と実践に踏み込んでいきます。