# 第9章: メモリ管理の高度なテクニック

## 学習目標
本章を修了すると、以下が可能になります：
- [ ] Rustのデフォルトアロケータの特性を理解し、カスタムアロケータが必要となるシナリオを判断できる。
- [ ] アリーナアロケータの概念とトレードオフを理解し、`bumpalo`クレートを使って利用できる。
- [ ] ゼロコピーの重要性を理解し、`Cow`やメモリマップドファイルといったテクニックを適用できる。

---

## 9.1 導入：デフォルトを越えて

Rustは、`jemalloc`（多くのプラットフォームで）のような、非常に高性能な汎用メモリアロケータをデフォルトで採用しています。これは、様々なサイズのメモリアロケーション要求に対して、速度とメモリ断片化のバランスを取るように設計されており、ほとんどのアプリケーションではこれで十分です。

しかし、パフォーマンスが極限まで求められる特定のシナリオでは、汎用アロケータのオーバーヘッドがボトルネックになることがあります。例えば、

-   非常に多数の小さなオブジェクトを、極めて高速に確保・解放する必要がある場合。
-   確保したオブジェクトの生存期間が全て同じで、一括で解放できる場合。
-   巨大なファイルを、メモリに全てロードすることなく処理したい場合。

本章では、このような特殊な要求に応えるための高度なメモリ管理テクニックを探求します。これらのテクニックは万能薬ではありませんが、プロファイリングによってメモリアロケーションやデータコピーがボトルネックであると特定された場合に、強力な武器となり得ます。

---

## 9.2 カスタムアロケータ

Rustでは、`GlobalAlloc`トレイトを実装することで、グローバルメモリアロケータを自作のものに置き換えることが可能です。しかし、アロケータを正しく、かつ効率的に実装することは極めて難しく、ほとんどの場合推奨されません。代わりに、特定のユースケースに特化したアロケータを提供するクレートを利用するのが一般的です。

### 9.2.1 アリーナアロケータ (Bump Allocator)

最も代表的なカスタムアロケータの一つが**アリーナアロケータ**です（バンプアロケータとも呼ばれます）。

**コンセプト:**
1.  最初に大きなメモリ領域（アリーナ）を一度だけ確保する。
2.  オブジェクトの確保要求が来ると、アリーナの未使用領域から、ポインタを必要なサイズ分だけ「進める（bump）」だけでメモリを割り当てる。
3.  個別のオブジェクトの解放は行わない。
4.  アリーナ全体が不要になったときに、全てのメモリを一括で解放する。

**利点:**
-   **極めて高速な確保:** ポインタを動かすだけなので、`malloc`のような複雑な処理が不要。
-   **断片化が起きない:** アリーナ内では常に一方向に確保が進むため、メモリの断片化が発生しません。

**欠点:**
-   **個別の解放ができない:** 一度確保したオブジェクトは、アリーナ全体が解放されるまでメモリを占有し続けます。

この特性から、アリーナアータは「多くのオブジェクトを生成し、短時間だけ使って、全てを一括で破棄する」ようなタスク（例：Webサーバーのリクエスト処理、コンパイラのステージ、ゲームのフレーム描画）に最適です。

### 9.2.2 実践：`bumpalo`クレート

安全なアリーナアロケータの実装を提供する`bumpalo`クレートを使うのが、最も簡単で推奨される方法です。

```rust
// 依存関係: bumpalo = { version = "3.9", features = ["collections"] }
use bumpalo::Bump;
use bumpalo::collections::Vec as BumpVec;

struct Point { x: i32, y: i32 }

fn main() {
    // 新しいアリーナを作成
    let bump = Bump::new();

    // このアリーナからPointを確保する
    // `&mut Point` ではなく `&'bump mut Point` が返ることに注意
    let p1 = bump.alloc(Point { x: 1, y: 2 });
    let p2 = bump.alloc(Point { x: 3, y: 4 });

    // アリーナからベクタを確保することもできる
    let mut vec = BumpVec::new_in(&bump);
    vec.push(10);
    vec.push(20);

    println!("p1: ({}, {})", p1.x, p1.y);
    println!("vec: {:?}", vec);

} // `bump`がスコープを抜ける。ここでアリーナ全体が一度に解放される。
```

---

## 9.3 ゼロコピー技術

パフォーマンスのボトルネックは、メモリアロケーションだけでなく、不要な**メモリコピー**によっても引き起こされます。特に、I/Oバウンドな処理やデータ集約的な処理では、メモリコピーの削減が劇的な性能向上に繋がることがあります。これを**ゼロコピー**と呼びます。

### 9.3.1 `Cow<T>` (Clone-on-Write)

`Cow<T>`（カウ）は、「書き込み時クローン」を実装したスマートポインタです。これは、データが変更されない限りは借用（Borrow）したデータを使い続け、変更が必要になった初めての瞬間に所有（Owned）するデータにクローンするという、効率化のためのテクニックです。

`Cow`は、関数がほとんどの場合は入力データのスライスをそのまま返せるが、時々修正が必要になる、というシナリオで特に有効です。

```rust
use std::borrow::Cow;

fn remove_emojis<'a>(text: &'a str) -> Cow<'a, str> {
    if text.contains('😀') {
        // 絵文字が含まれている場合のみ、新しいStringを確保して返す
        Cow::Owned(text.replace('😀', ""))
    } else {
        // 変更不要な場合は、元のスライスを借用したまま返す（コピーしない）
        Cow::Borrowed(text)
    }
}

fn main() {
    let text_with_emoji = "Hello 😀 World!";
    let text_without_emoji = "Hello World!";

    // `remove_emojis`は、必要に応じて`String`を確保する
    let processed1 = remove_emojis(text_with_emoji);
    let processed2 = remove_emojis(text_without_emoji);

    // CowはDerefを実装しているので、&strのように扱える
    println!("Processed 1: {}", processed1);
    println!("Processed 2: {}", processed2);

    // 型を確認
    assert!(matches!(processed1, Cow::Owned(_)));
    assert!(matches!(processed2, Cow::Borrowed(_)));
}
```

### 9.3.2 メモリマップドファイル

巨大なファイル（数GB以上）を扱う際、ファイル全体をメモリに読み込むのは非効率的、あるいは不可能です。**メモリマップドファイル**は、OSの仮想記憶システムを利用して、ファイルの内容をメモリ空間に直接マッピングする技術です。

これにより、ファイルがまるで巨大なメモリスライスであるかのようにアクセスできます。OSは、実際にアクセスされた部分のデータだけを、必要に応じて物理メモリに読み込みます（ページング）。これにより、最小限のメモリ使用量で、巨大なファイルに対して高速なランダムアクセスが可能になります。

Rustでこれを安全に行うには、`memmap2`クレートが推奨されます。

```rust
// 依存関係: memmap2 = "0.5"
use memmap2::Mmap;
use std::fs::File;
use std::io::Result;

fn main() -> Result<()> {
    let file = File::open("huge_file.dat")?;
    // ファイルを読み込み専用でメモリにマッピング
    let mmap = unsafe { Mmap::map(&file)? };

    // mmapは &[u8] スライスのように振る舞う
    println!("File size is {} bytes", mmap.len());

    // ファイルの先頭10バイトを表示（メモリコピーは最小限）
    if mmap.len() > 10 {
        println!("First 10 bytes: {:?}", &mmap[0..10]);
    }

    Ok(())
}
```
`unsafe`が必要なのは、マッピング中に他のプロセスによってファイルが変更される可能性があるため、その安全性をプログラマが保証する必要があるからです。

---

## 9.4 まとめ

本章では、Rustの標準的なメモリ管理を超えた、パフォーマンスを追求するための高度なテクニックを学びました。

-   **カスタムアロケータ**（特にアリーナアロケータ）は、オブジェクトの確保と解放のパターンが特殊な場合に、デフォルトの汎用アロケータを大幅に上回る性能を発揮します。
-   **ゼロコピー技術**（`Cow`やメモリマップドファイル）は、不要なデータコピーを削減することで、特にデータ集約的なアプリケーションの性能を劇的に改善します。

これらのテクニックは、常に適用すべきものではありません。しかし、プロファイリングによってメモリアロケーションやデータコピーが明確なボトルネックとして特定されたとき、あなたのツールボックスに入っていると非常に心強い、強力な選択肢となるでしょう。