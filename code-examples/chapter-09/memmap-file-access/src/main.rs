use memmap2::Mmap;use std::fs::{self, File};use std::io::{self, Write};use std::path::Path;fn main() -> io::Result<()> {    let file_path = Path::new("large_file.txt");    let file_size = 1024 * 1024 * 10; // 10 MB    // 1. デモンストレーション用のダミーの大きなファイルを作成    if !file_path.exists() {        println!("ダミーの大きなファイルを作成中: {}", file_path.display());        let mut file = File::create(file_path)?;        // ダミーデータを書き込んでファイルを大きくする        let dummy_data = b"Hello, memory-mapped file! This is a line of text.\n";        for _ in 0..(file_size / dummy_data.len()) {            file.write_all(dummy_data)?;        }        file.sync_all()?; // データがディスクに書き込まれることを保証        println!("ダミーファイルが {} バイトで作成されました。", file_size);    } else {        println!("既存のダミーファイルを使用中: {}", file_path.display());    }    // 2. ファイルを開き、メモリマップする    let file = File::open(file_path)?;    // `Mmap::map`は低レベルな操作であり、誤って使用すると未定義動作につながる可能性があるため、`unsafe`である。    let mmap = unsafe { Mmap::map(&file)? };    println!("\nファイルが正常にメモリマップされました。サイズ: {} バイト。", mmap.len());    // 3. メモリ内のスライスのようにデータにアクセスする    println!("最初の50バイト: {:?}", &mmap[0..50]);    println!("1MB地点のバイト: {}", mmap[1024 * 1024]);    println!("5MB地点のバイト: {}", mmap[1024 * 1024 * 5]);    // マップされたメモリ内で検索することもできる    if let Some(pos) = mmap.windows(5).position(|window| window == b"line.") {        println!("'line.' が位置: {} で見つかりました", pos);    }    // `mmap`がスコープを抜けるときに、メモリマップされたファイルは自動的にアンマップされる。    println!("\n`mmap`がスコープを抜けるときに、メモリマップされたファイルはアンマップされます。");    // ダミーファイルをクリーンアップ    fs::remove_file(file_path)?;    println!("ダミーファイルがクリーンアップされました。");    Ok(())}