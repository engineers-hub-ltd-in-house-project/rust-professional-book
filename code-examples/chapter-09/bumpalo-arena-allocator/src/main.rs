use bumpalo::Bump;use bumpalo::collections::Vec as BumpVec;use std::time::Instant;// 確保するシンプルな構造体struct MyData {_id: u32,_name: String,_values: Vec<f64>,}fn main() {    const NUM_ALLOCATIONS: usize = 100_000;    println!("--- 標準アロケータ (Vec<String>) ---");    let start = Instant::now();    let mut standard_vec = Vec::with_capacity(NUM_ALLOCATIONS);    for i in 0..NUM_ALLOCATIONS {        standard_vec.push(format!("Item {}", i));    }    let duration = start.elapsed();    println!("{}個のStringを確保しました: {:?}", NUM_ALLOCATIONS, duration);    // `standard_vec`はドロップされ、各Stringは個別に解放される。    println!("\n--- Bumpaloアリーナアロケータ ---");    let bump = Bump::new(); // 新しいアリーナを作成    let start = Instant::now();    let mut bump_vec = BumpVec::new_in(&bump); // アリーナ内にVecを確保    for i in 0..NUM_ALLOCATIONS {        // アリーナ内にStringを確保        let s = bump.alloc_str(&format!("Item {}", i));        bump_vec.push(s);    }    let duration = start.elapsed();    println!("{}個のStringを確保しました: {:?}", NUM_ALLOCATIONS, duration);    // `bump`がスコープを抜けるとき、そこから確保された全てのメモリは一度に解放される。    println!("\n--- カスタム構造体に対するBumpalo ---");    let bump_custom = Bump::new();    let start = Instant::now();    let mut custom_data_vec = BumpVec::new_in(&bump_custom);    for i in 0..NUM_ALLOCATIONS {        let data = bump_custom.alloc(MyData {            _id: i as u32,            _name: format!("Data {}", i),            _values: vec![i as f64, (i * 2) as f64],        });        custom_data_vec.push(data);    }    let duration = start.elapsed();    println!("{}個のカスタム構造体を確保しました: {:?}", NUM_ALLOCATIONS, duration);    println!("\n例が終了しました。Bumpaloの性能差と単一解放を観察してください。");}