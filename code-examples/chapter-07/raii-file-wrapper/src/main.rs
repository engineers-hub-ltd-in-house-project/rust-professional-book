use std::ffi::CString;use std::io::{self, Write};use std::os::unix::io::RawFd; // Unix固有のファイルディスクリプタ型// 生のファイルディスクリプタ (RawFd) をラップする安全な構造体。// この構造体はRAIIパターンを実装している。pub struct File {    fd: RawFd,}impl File {    pub fn open(path: &str) -> io::Result<File> {        let c_path = CString::new(path)?;        let fd = unsafe {            // Cの`open`システムコールを呼び出す。これはRustコンパイラが            // その正しさを保証できないため`unsafe`である。            libc::open(c_path.as_ptr(), libc::O_RDWR | libc::O_CREAT | libc::O_TRUNC, 0o644)        };        if fd < 0 {            // `open`がエラーを返した場合、OSのエラーコードをRustの`io::Error`に変換する。            Err(io::Error::last_os_error())        } else {            Ok(File { fd })        }    }    pub fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {        let bytes_written = unsafe {            // Cの`write`システムコールを呼び出す。これも`unsafe`である。            libc::write(self.fd, buf.as_ptr() as *const libc::c_void, buf.len())        };        if bytes_written < 0 {            Err(io::Error::last_os_error())        } else if bytes_written as usize != buf.len() {            Err(io::Error::new(io::ErrorKind::WriteZero, "failed to write entire buffer"))        } else {            Ok(())        }    }}// `Drop`トレイトの実装により、`File`構造体がスコープを抜けるときに// 自動的に`close()`が呼ばれることが保証される。impl Drop for File {    fn drop(&mut self) {        let result = unsafe {            // Cの`close`システムコールを呼び出す。これも`unsafe`である。            libc::close(self.fd)        };        if result < 0 {            // `drop`の中では、通常パニックしたりエラーを返したりすることはできない。            // そのため、クローズに失敗した場合はstderrに出力するだけにする。            eprintln!("Error closing file descriptor {}: {}", self.fd, io::Error::last_os_error());        }    }}fn main() -> io::Result<()> {    let file_path = "my_raii_file.txt";    println!("'{}' を開いて書き込みを試みます", file_path);    // `File::open`は、内部で`unsafe`なlibc呼び出しを使用しているが、安全なRust関数である。    let mut my_file = File::open(file_path)?;    println!("ファイルが正常に開かれました。FD: {}", my_file.fd);    my_file.write_all(b"Hello, RAII from Rust!\n")?;    println!("データがファイルに書き込まれました。");    // `my_file`はここでスコープを抜ける。その`drop`メソッドが自動的に呼ばれ、    // 早期リターンやパニックが発生しても`libc::close()`が実行されることが保証される。    println!("`my_file`がスコープを抜けるときに、ファイルは自動的に閉じられます。");    // 早期リターンをデモンストレーションする:    if true {        println!("main関数から早期リターンします。");        return Ok(());    }    // この行はこの例では到達しないが、もし到達したとしても、    // `my_file`は依然としてドロップされる。    println!("この行は早期リターンの後です。");    Ok(())}