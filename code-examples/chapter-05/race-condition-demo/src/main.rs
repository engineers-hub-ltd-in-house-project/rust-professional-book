use std::thread;use std::time::Duration;fn main() {    // このカウンターはスレッドセーフではない。    // `counter`は最初のスレッドにムーブされるため、    // その後のスレッドにはムーブできず、コンパイルエラーになる。    // 仮に共有できたとしても、データ競合を引き起こすだろう。    let mut counter = 0;    let mut handles = vec![];    println!("10個のスレッドでカウンターを10,000までインクリメントしようとしています...");    for i in 0..10 {        // 以下の行はコンパイルエラーになる：        // `counter`はクロージャにムーブされるため、その後のイテレーションでは使用できない。        //        // let handle = thread::spawn(move || {        //     for _ in 0..1000 {        //         counter += 1;        //     }        // });        // handles.push(handle);        // Rustがデータ競合の概念をどのように防ぐかを示すため、        // ここではコンパイルエラーになることを示している。        println!("スレッド {} はカウンターをインクリメントしようとします。", i);    }    // もし上記のループが許された場合、最終的なカウンターの値は一貫性がなく、    // おそらく10,000未満になるだろう。    println!("\nこのコードは現状ではコンパイルできません。Rustの安全性が示されています。");    println!("`counter`変数は、同期プリミティブなしではスレッド間で安全に共有できません。");    println!("期待される最終カウント: 10,000 (もしコンパイルされ、正しく動作した場合)");    println!("実際の最終カウント (もし安全でない形でコンパイルされた場合): 一貫性がなく、おそらく10,000未満。");    // これをコンパイルして問題を示すには、`unsafe`や`static mut`を使う必要があるが、    // それらは強く推奨されない。Rustはこのような一般的な間違いをコンパイル時に防ぐ。}